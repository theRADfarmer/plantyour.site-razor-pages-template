/**
 * Minified by jsDelivr using Terser v5.37.0.
 * Original file: /npm/alpinejs@3.14.9/src/mutation.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{dequeueJob}from"./scheduler";let onAttributeAddeds=[],onElRemoveds=[],onElAddeds=[];export function onElAdded(e){onElAddeds.push(e)}export function onElRemoved(e,t){"function"==typeof t?(e._x_cleanups||(e._x_cleanups=[]),e._x_cleanups.push(t)):(t=e,onElRemoveds.push(t))}export function onAttributesAdded(e){onAttributeAddeds.push(e)}export function onAttributeRemoved(e,t,n){e._x_attributeCleanups||(e._x_attributeCleanups={}),e._x_attributeCleanups[t]||(e._x_attributeCleanups[t]=[]),e._x_attributeCleanups[t].push(n)}export function cleanupAttributes(e,t){e._x_attributeCleanups&&Object.entries(e._x_attributeCleanups).forEach((([n,u])=>{(void 0===t||t.includes(n))&&(u.forEach((e=>e())),delete e._x_attributeCleanups[n])}))}export function cleanupElement(e){for(e._x_effects?.forEach(dequeueJob);e._x_cleanups?.length;)e._x_cleanups.pop()()}let observer=new MutationObserver(onMutate),currentlyObserving=!1;export function startObservingMutations(){observer.observe(document,{subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0}),currentlyObserving=!0}export function stopObservingMutations(){flushObserver(),observer.disconnect(),currentlyObserving=!1}let queuedMutations=[];export function flushObserver(){let e=observer.takeRecords();queuedMutations.push((()=>e.length>0&&onMutate(e)));let t=queuedMutations.length;queueMicrotask((()=>{if(queuedMutations.length===t)for(;queuedMutations.length>0;)queuedMutations.shift()()}))}export function mutateDom(e){if(!currentlyObserving)return e();stopObservingMutations();let t=e();return startObservingMutations(),t}let isCollecting=!1,deferredMutations=[];export function deferMutations(){isCollecting=!0}export function flushAndStopDeferringMutations(){isCollecting=!1,onMutate(deferredMutations),deferredMutations=[]}function onMutate(e){if(isCollecting)return void(deferredMutations=deferredMutations.concat(e));let t=[],n=new Set,u=new Map,o=new Map;for(let r=0;r<e.length;r++)if(!e[r].target._x_ignoreMutationObserver&&("childList"===e[r].type&&(e[r].removedNodes.forEach((e=>{1===e.nodeType&&e._x_marker&&n.add(e)})),e[r].addedNodes.forEach((e=>{1===e.nodeType&&(n.has(e)?n.delete(e):e._x_marker||t.push(e))}))),"attributes"===e[r].type)){let t=e[r].target,n=e[r].attributeName,s=e[r].oldValue,i=()=>{u.has(t)||u.set(t,[]),u.get(t).push({name:n,value:t.getAttribute(n)})},a=()=>{o.has(t)||o.set(t,[]),o.get(t).push(n)};t.hasAttribute(n)&&null===s?i():t.hasAttribute(n)?(a(),i()):a()}o.forEach(((e,t)=>{cleanupAttributes(t,e)})),u.forEach(((e,t)=>{onAttributeAddeds.forEach((n=>n(t,e)))}));for(let e of n)t.some((t=>t.contains(e)))||onElRemoveds.forEach((t=>t(e)));for(let e of t)e.isConnected&&onElAddeds.forEach((t=>t(e)));t=null,n=null,u=null,o=null}
//# sourceMappingURL=/sm/de699da42d89a792285b27cf665b6a54cc4eb0ddd7504610926934f40d288c45.map